/*
 * Copyright 2023 Markus Bordihn
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.markusbordihn.easynpc.entity.easynpc.npc.raw;

import static java.util.Objects.hash;

import de.markusbordihn.easynpc.Constants;
import de.markusbordihn.easynpc.data.configuration.ConfigurationData;
import de.markusbordihn.easynpc.data.model.ModelPartType;
import de.markusbordihn.easynpc.data.model.ModelType;
import de.markusbordihn.easynpc.data.scale.CustomScale;
import de.markusbordihn.easynpc.data.server.ServerEntityData;
import de.markusbordihn.easynpc.data.skin.SkinModel;
import de.markusbordihn.easynpc.data.skin.variant.ZombieSkinVariant;
import de.markusbordihn.easynpc.data.status.StatusDataType;
import de.markusbordihn.easynpc.data.synched.SynchedDataIndex;
import de.markusbordihn.easynpc.data.synched.SynchedEntityData;
import de.markusbordihn.easynpc.data.ticker.TickerType;
import de.markusbordihn.easynpc.entity.easynpc.EasyNPC;
import de.markusbordihn.easynpc.entity.easynpc.EasyNPCBase;
import de.markusbordihn.easynpc.entity.easynpc.handlers.AttackHandler;
import de.markusbordihn.easynpc.entity.easynpc.handlers.InteractionHandler;
import de.markusbordihn.easynpc.entity.easynpc.handlers.VisibilityHandler;
import de.markusbordihn.easynpc.handler.AttributeHandler;
import de.markusbordihn.easynpc.network.syncher.EntityDataSerializersManager;
import de.markusbordihn.easynpc.server.player.FakePlayer;
import de.markusbordihn.easynpc.utils.TextUtils;
import java.util.EnumMap;
import java.util.Objects;
import java.util.UUID;
import net.minecraft.core.BlockPos;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.syncher.EntityDataAccessor;
import net.minecraft.network.syncher.EntityDataSerializers;
import net.minecraft.network.syncher.SynchedEntityData.Builder;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.sounds.SoundEvent;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;
import net.minecraft.util.TimeUtil;
import net.minecraft.util.valueproviders.UniformInt;
import net.minecraft.world.DifficultyInstance;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.damagesource.DamageSource;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.EntityDimensions;
import net.minecraft.world.entity.EntityType;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.MobSpawnType;
import net.minecraft.world.entity.Pose;
import net.minecraft.world.entity.SpawnGroupData;
import net.minecraft.world.entity.ai.goal.GoalSelector;
import net.minecraft.world.entity.monster.Zombie;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.ProjectileWeaponItem;
import net.minecraft.world.item.trading.MerchantOffer;
import net.minecraft.world.item.trading.MerchantOffers;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.ServerLevelAccessor;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.portal.DimensionTransition;
import net.minecraft.world.phys.Vec3;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

// TEMPLATE_INSERT:IMPORTS

/*
 * ⚠️ WARNING: This file is auto-generated. DO NOT EDIT THIS FILE DIRECTLY!
 *
 * Any manual changes will be overwritten during the next build.
 * To add custom logic or methods to this class, please use a corresponding `.methods` file.
 *
 * This class is generated by the `generateRawNPCs` Gradle task.
 */
public class NPCRawTemplate extends Zombie implements EasyNPCBase<Zombie> {

  public static final String ID = "npc_raw_template";

  protected static final Logger log = LogManager.getLogger(Constants.LOG_NAME);
  protected static final EnumMap<SynchedDataIndex, EntityDataAccessor<?>> entityDataAccessorMap =
      new EnumMap<>(SynchedDataIndex.class);
  private static final UniformInt PERSISTENT_ANGER_TIME = TimeUtil.rangeOfSeconds(20, 39);

  static {
    // Attack Data
    entityDataAccessorMap.put(
        SynchedDataIndex.ATTACK_IS_CHARGING_CROSSBOW,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializers.BOOLEAN));

    // Attribute Data
    entityDataAccessorMap.put(
        SynchedDataIndex.ENTITY_ATTRIBUTES,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.ENTITY_ATTRIBUTES));

    // Display Attribute Data
    entityDataAccessorMap.put(
        SynchedDataIndex.DISPLAY_ATTRIBUTE_SET,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.DISPLAY_ATTRIBUTE));

    // Model Data
    entityDataAccessorMap.put(
        SynchedDataIndex.MODEL_POSE,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MODEL_POSE));
    entityDataAccessorMap.put(
        SynchedDataIndex.MODEL_ANIMATION,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MODEL_ANIMATION_DATA));
    entityDataAccessorMap.put(
        SynchedDataIndex.MODEL_POSITION,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MODEL_PART_POSITION));
    entityDataAccessorMap.put(
        SynchedDataIndex.MODEL_ROTATION,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MODEL_PART_ROTATION));
    entityDataAccessorMap.put(
        SynchedDataIndex.MODEL_SCALE,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MODEL_PART_SCALE));
    entityDataAccessorMap.put(
        SynchedDataIndex.MODEL_VISIBILITY,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MODEL_PART_VISIBILITY));

    // Navigation Data
    entityDataAccessorMap.put(
        SynchedDataIndex.NAVIGATION_HOME_POSITION,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializers.BLOCK_POS));

    // Owner Data
    entityDataAccessorMap.put(
        SynchedDataIndex.OWNER_UUID,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializers.OPTIONAL_UUID));

    // Profession Data
    entityDataAccessorMap.put(
        SynchedDataIndex.PROFESSION,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.PROFESSION));

    // Render Data
    entityDataAccessorMap.put(
        SynchedDataIndex.RENDER_DATA,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.RENDER_DATA_ENTRY));

    // Skin Data
    entityDataAccessorMap.put(
        SynchedDataIndex.SKIN_DATA,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.SKIN_DATA_ENTRY));

    // Sound Data
    entityDataAccessorMap.put(
        SynchedDataIndex.SOUND_DATA_SET,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.SOUND_DATA_SET));

    // Trading Data
    entityDataAccessorMap.put(
        SynchedDataIndex.TRADING_DATA_SET,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.TRADING_DATA_SET));
    entityDataAccessorMap.put(
        SynchedDataIndex.TRADING_INVENTORY,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializers.COMPOUND_TAG));
    entityDataAccessorMap.put(
        SynchedDataIndex.TRADING_MERCHANT_OFFERS,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializersManager.MERCHANT_OFFERS));

    // Variant Data
    entityDataAccessorMap.put(
        SynchedDataIndex.VARIANT_TYPE,
        net.minecraft.network.syncher.SynchedEntityData.defineId(
            NPCRawTemplate.class, EntityDataSerializers.STRING));
  }

  private final EnumMap<TickerType, Integer> tickerMap = new EnumMap<>(TickerType.class);
  private final EnumMap<StatusDataType, Boolean> statusDataFlagMap =
      new EnumMap<>(StatusDataType.class);
  protected MerchantOffers merchantTradingOffers;
  private ServerEntityData serverEntityData;
  private int attackAnimationTick;
  private int npcDataVersion = -1;
  private UUID persistentAngerTarget;
  private int remainingPersistentAngerTime;
  private SynchedEntityData synchedEntityData;
  private Player tradingPlayer;
  private FakePlayer fakePlayer;

  public NPCRawTemplate(EntityType<? extends Zombie> entityType, Level level, Enum<?> variant) {
    super(entityType, level);
    this.registerEasyNPCDefaultVariant(variant);
  }

  public NPCRawTemplate(EntityType<? extends Zombie> entityType, Level level) {
    super(entityType, level);
  }

  @Override
  public FakePlayer getFakePlayer(ServerLevel level, BlockPos blockPos) {
    if (FakePlayer.isInvalidFakePlayer(this.fakePlayer)) {
      this.fakePlayer = new FakePlayer(level, blockPos);
      return this.fakePlayer;
    }
    return this.fakePlayer.updatePosition(level, blockPos);
  }

  @Override
  public int getTicker(TickerType tickerType) {
    return this.tickerMap.getOrDefault(tickerType, 0);
  }

  @Override
  public void setTicker(TickerType tickerType, int ticker) {
    this.tickerMap.put(tickerType, ticker);
  }

  @Override
  public EnumMap<StatusDataType, Boolean> getStatusDataFlags() {
    return this.statusDataFlagMap;
  }

  @Override
  public void onCrossbowAttackPerformed() {
    this.noActionTime = 0;
  }

  @Override
  public int getAttackAnimationTick() {
    return this.attackAnimationTick;
  }

  @Override
  public boolean doHurtTarget(Entity entity) {
    this.attackAnimationTick = 10;
    this.level().broadcastEntityEvent(this, (byte) 4);
    return super.doHurtTarget(entity);
  }

  @Override
  public void handleEntityEvent(byte flag) {
    super.handleEntityEvent(flag);
    if (flag == 4) {
      this.attackAnimationTick = 10;
    }
  }

  @Override
  public void aiStep() {
    super.aiStep();

    if (this.isClientSideInstance()) {
      this.updateSwingTime();
      if (this.attackAnimationTick > 0) {
        --this.attackAnimationTick;
      }
    } else {
      this.updatePersistentAnger((ServerLevel) this.level(), true);
    }
  }

  @Override
  public Component getName() {
    Component component = this.getCustomName();
    return component != null ? TextUtils.removeAction(component) : this.getTypeName();
  }

  @Override
  public boolean hurt(DamageSource damageSource, float damage) {
    this.handleHurtEvent(damageSource, damage);
    return super.hurt(damageSource, damage);
  }

  @Override
  public void die(DamageSource damageSource) {
    this.handleDieEvent(damageSource);
    super.die(damageSource);
  }

  @Override
  public void kill() {
    this.handleKillEvent();
    super.kill();
  }

  @Override
  public Entity changeDimension(DimensionTransition dimensionTransition) {
    this.handleChangeDimensionEvent(dimensionTransition);
    return super.changeDimension(dimensionTransition);
  }

  @Override
  public InteractionResult mobInteract(Player player, InteractionHand hand) {
    return InteractionHandler.handleMobInteraction(this, player, hand);
  }

  @Override
  public boolean isClientSide() {
    return this.isClientSideInstance();
  }

  @Override
  public boolean isInvisible() {
    return VisibilityHandler.handleIsInvisible(this, super.isInvisible());
  }

  @Override
  public boolean isInvisibleTo(Player player) {
    return VisibilityHandler.handleIsInvisibleToPlayer(this, player, super.isInvisibleTo(player));
  }

  @Override
  public Player getTradingPlayer() {
    return this.tradingPlayer;
  }

  @Override
  public void setTradingPlayer(Player player) {
    this.tradingPlayer = player;
  }

  @Override
  public MerchantOffers getMerchantTradingOffers() {
    return this.merchantTradingOffers;
  }

  @Override
  public void setMerchantTradingOffers(MerchantOffers merchantOffers) {
    this.merchantTradingOffers = merchantOffers;
  }

  @Override
  public void rewardTradeXp(MerchantOffer merchantOffer) {
    this.rewardMerchantTradeXp(merchantOffer);
  }

  @Override
  public void stopTrading() {
    this.stopMerchantTrading();
  }

  @Override
  public int getNPCDataVersion() {
    return this.npcDataVersion;
  }

  @Override
  public void setNPCDataVersion(int version) {
    this.npcDataVersion = version;
  }

  @Override
  public SpawnGroupData finalizeSpawn(
      ServerLevelAccessor serverLevelAccessor,
      DifficultyInstance difficulty,
      MobSpawnType mobSpawnType,
      SpawnGroupData spawnGroupData) {
    AttributeHandler.handleDefaultAttributes(this);
    return finalizeEasyNPCSpawn(
        super.finalizeSpawn(serverLevelAccessor, difficulty, mobSpawnType, spawnGroupData));
  }

  @Override
  public void handleEasyNPCJoinEvent(EasyNPC<?> easyNPC) {
    this.onEasyNPCJoinUpdateObjective(easyNPC);
  }

  @Override
  public void handleEasyNPCLeaveEvent(EasyNPC<?> easyNPC) {
    this.onEasyNPCLeaveUpdateObjective(easyNPC);
  }

  @Override
  public void handlePlayerJoinEvent(ServerPlayer serverPlayer) {
    this.onPlayerJoinUpdateObjective(serverPlayer);
  }

  @Override
  public void handlePlayerLeaveEvent(ServerPlayer serverPlayer) {
    this.onPlayerLeaveUpdateObjective(serverPlayer);
  }

  @Override
  public void handleLivingEntityJoinEvent(LivingEntity livingEntity) {
    this.onLivingEntityJoinUpdateObjective(livingEntity);
  }

  @Override
  public void handleLivingEntityLeaveEvent(LivingEntity livingEntity) {
    this.onLivingEntityLeaveUpdateObjective(livingEntity);
  }

  @Override
  public boolean canFireProjectileWeapon(ProjectileWeaponItem projectileWeaponItem) {
    return AttackHandler.canFireProjectileWeapon(projectileWeaponItem);
  }

  @Override
  public int getRemainingPersistentAngerTime() {
    return this.remainingPersistentAngerTime;
  }

  @Override
  public void setRemainingPersistentAngerTime(int remainingPersistentAngerTime) {
    this.remainingPersistentAngerTime = remainingPersistentAngerTime;
  }

  @Override
  public UUID getPersistentAngerTarget() {
    return this.persistentAngerTarget;
  }

  @Override
  public void setPersistentAngerTarget(UUID targetUUID) {
    this.persistentAngerTarget = targetUUID;
  }

  @Override
  public void startPersistentAngerTimer() {
    this.setRemainingPersistentAngerTime(PERSISTENT_ANGER_TIME.sample(this.random));
  }

  @Override
  public GoalSelector getEntityGoalSelector() {
    return this.goalSelector;
  }

  @Override
  public GoalSelector getEntityTargetSelector() {
    return this.targetSelector;
  }

  @Override
  public <T> void defineSynchedEntityData(
      Builder builder, SynchedDataIndex synchedDataIndex, T defaultData) {
    if (this.synchedEntityData == null) {
      this.synchedEntityData = new SynchedEntityData(this, entityDataAccessorMap);
    }
    this.synchedEntityData.define(builder, synchedDataIndex, defaultData);
  }

  @Override
  public <T> void setSynchedEntityData(
      SynchedDataIndex synchedDataIndex, T data, boolean forceUpdate) {
    this.synchedEntityData.set(synchedDataIndex, data, forceUpdate);
  }

  @Override
  public <T> T getSynchedEntityData(SynchedDataIndex synchedDataIndex) {
    return this.synchedEntityData.get(synchedDataIndex);
  }

  @Override
  public void defineServerEntityData() {
    this.serverEntityData = new ServerEntityData(this);
  }

  @Override
  public ServerEntityData getServerEntityData() {
    if (this.serverEntityData == null) {
      this.defineServerEntityData();
    }
    return this.serverEntityData;
  }

  @Override
  public boolean canBeLeashed() {
    return super.canBeLeashed() && getEntityAttributes().getInteractionAttributes().canBeLeashed();
  }

  @Override
  public boolean isAttackable() {
    return getEntityAttributes().getCombatAttributes().isAttackableByPlayers();
  }

  @Override
  public boolean isPushable() {
    return getEntityAttributes().getInteractionAttributes().isPushable();
  }

  @Override
  public boolean canBeHitByProjectile() {
    return getEntityAttributes().getInteractionAttributes().canBeHitByProjectile()
        && this.isAlive();
  }

  @Override
  protected void pushEntities() {
    if (getEntityAttributes().getInteractionAttributes().pushEntities()) {
      super.pushEntities();
    }
  }

  @Override
  public boolean isInvulnerable() {
    return getEntityAttributes().getCombatAttributes().isInvulnerable();
  }

  @Override
  public boolean isInvulnerableTo(DamageSource damageSource) {
    return AttackHandler.handleIsInvulnerableTo(
        this, damageSource, super.isInvulnerableTo(damageSource));
  }

  @Override
  public void playAmbientSound() {
    this.playDefaultAmbientSound();
  }

  @Override
  public int getAmbientSoundInterval() {
    return 240;
  }

  @Override
  public void playHurtSound(DamageSource damageSource) {
    this.playDefaultHurtSound(damageSource);
  }

  @Override
  protected void playStepSound(BlockPos blockPos, BlockState blockState) {
    this.playDefaultStepSound(blockPos, blockState);
  }

  @Override
  public SoundEvent getDeathSound() {
    return this.getDefaultDeathSound();
  }

  @Override
  protected void handlePortal() {
    if (getEntityAttributes().getMovementAttributes().canUseNetherPortal()) {
      super.handlePortal();
    }
  }

  @Override
  protected boolean shouldDespawnInPeaceful() {
    return false;
  }

  @Override
  public boolean removeWhenFarAway(double distance) {
    return false;
  }

  @Override
  public void baseTick() {
    super.baseTick();

    // Early exit for client side and dead entities.
    if (this.isClientSideInstance() || !this.isAlive()) {
      return;
    }

    // Handle custom objective base tick.
    this.handleCustomObjectiveBaseTick();

    // Handle base tick for specific conditions.
    this.handleBaseTick();
  }

  @Override
  public void travel(Vec3 vec3) {
    this.handleNavigationTravelEvent(vec3);
    super.travel(vec3);
  }

  @Override
  public boolean isSaddleable() {
    return false;
  }

  @Override
  public void equipSaddle(ItemStack itemStack, SoundSource soundSource) {
    if (soundSource != null) {
      this.level().playSound(null, this, SoundEvents.PIG_SADDLE, soundSource, 0.5F, 1.0F);
    }
  }

  @Override
  public boolean isSaddled() {
    return false;
  }

  @Override
  public ConfigurationData getConfigurationData() {
    return ConfigurationData.RAW;
  }

  @Override
  public SkinModel getSkinModel() {
    return SkinModel.ZOMBIE;
  }

  @Override
  public ModelType getModelType() {
    return ModelType.ZOMBIE;
  }

  @Override
  public Enum<?>[] getSkinVariantTypes() {
    return ZombieSkinVariant.values();
  }

  @Override
  public Enum<?> getDefaultSkinVariantType() {
    return ZombieSkinVariant.ZOMBIE;
  }

  @Override
  public Enum<?> getSkinVariantType(String name) {
    try {
      return ZombieSkinVariant.valueOf(name);
    } catch (IllegalArgumentException e) {
      return getDefaultSkinVariantType();
    }
  }

  @Override
  protected void defineSynchedData(
      net.minecraft.network.syncher.SynchedEntityData.Builder builder) {
    super.defineSynchedData(builder);
    this.defineEasyNPCBaseSyncedData(builder);
    this.defineEasyNPCBaseServerSideData();
  }

  @Override
  public void addAdditionalSaveData(CompoundTag compoundTag) {
    super.addAdditionalSaveData(compoundTag);
    this.addPersistentAngerSaveData(compoundTag);
    this.addEasyNPCBaseAdditionalSaveData(compoundTag, this.registryAccess());
  }

  @Override
  public void readAdditionalSaveData(CompoundTag compoundTag) {
    super.readAdditionalSaveData(compoundTag);
    this.readPersistentAngerSaveData(this.level(), compoundTag);
    this.readEasyNPCBaseAdditionalSaveData(compoundTag, this.registryAccess());
  }

  @Override
  public EntityDimensions getDefaultDimensions(Pose pose) {
    CustomScale rootScale = getModelPartScale(ModelPartType.ROOT);
    if (rootScale.x() != 1.0f || rootScale.y() != 1.0f) {
      EntityDimensions baseDimensions = super.getDefaultDimensions(pose);
      return baseDimensions.scale(rootScale.x(), rootScale.y());
    }

    return super.getDefaultDimensions(pose);
  }

  // TEMPLATE_INSERT:METHODS

  @Override
  public boolean equals(Object object) {
    if (this == object) {
      return true;
    }
    if (!(object instanceof EasyNPCBase<?> easyNPCBase)) {
      return false;
    }
    return Objects.equals(this.getUUID(), easyNPCBase.getEntityUUID());
  }

  @Override
  public int hashCode() {
    return hash(this.getUUID());
  }

  @Override
  public boolean isCustomNameVisible() {
    return VisibilityHandler.handleIsCustomNameVisible(this, super.isCustomNameVisible());
  }
}
